<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Echo ‚Äì Anonymous Voice Connect</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
/* Your existing CSS remains the same */
/* ... [All your existing CSS code] ... */
</style>
</head>
<body>
  <div class="header-buttons" role="toolbar" aria-label="Top controls">
    <button id="guideBtn" class="header-btn" title="Guide">‚ùî Guide</button>
    <button id="themeBtn" class="header-btn" title="Toggle theme">üåó Theme</button>
  </div>

  <div class="app" id="app" hidden>
    <h2>Echo ‚Äì Anonymous Voice Connect</h2>
    <p class="sub">Record ‚Üí Upload ‚Üí Share. Professional voice messaging made simple.</p>

    <!-- Enhanced Mobile Warning -->
    <div class="mobile-warning" id="mobileWarning">
      <strong>üì± Mobile Tips:</strong> 
      <ul style="text-align: left; margin: 10px 0; padding-left: 20px;">
        <li>Use headphones for better recording quality</li>
        <li>Allow microphone permissions when prompted</li>
        <li>Use Chrome or Safari for best compatibility</li>
        <li>Make sure your device volume is turned up</li>
      </ul>
    </div>

    <!-- sender -->
    <div id="senderView">
      <label for="privacy">Privacy Setting</label>
      <div class="select-wrap">
        <select id="privacy" name="privacy">
          <option value="anonymous">Anonymous - Hide identity</option>
          <option value="reveal_on_request">Reveal on Request - Approve identity requests</option>
          <option value="auto_reveal">Auto Reveal - Show identity automatically</option>
        </select>
      </div>

      <label for="expiry">Message Expiry</label>
      <div class="select-wrap">
        <select id="expiry" name="expiry">
          <option value="permanent">Permanent - Never expires</option>
          <option value="24h">24 hours - Auto-deletes after 1 day</option>
          <option value="1h">1 hour - Quick temporary message</option>
        </select>
      </div>

      <label for="senderName">Your Display Name</label>
      <input id="senderName" placeholder="Enter your name or stay anonymous" />

      <!-- Enhanced Recording Section -->
      <div class="recording-section" style="text-align: center; margin: 20px 0;">
        <div class="mic" id="micBtn" title="Start recording">
          <span>üéôÔ∏è</span>
        </div>
        <div id="recordingStatus" style="margin: 10px 0; min-height: 20px;"></div>
        <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
          <button id="stopBtn" disabled>‚èπ Stop Recording</button>
          <button id="uploadBtn" hidden class="btn-primary">‚¨ÜÔ∏è Upload Voice</button>
        </div>
      </div>
      
      <!-- Audio Preview with Enhanced Fallback -->
      <div id="audioPreviewSection" style="margin-top: 20px;" class="hidden">
        <p style="text-align: center; margin-bottom: 10px; font-weight: 500;">üéß Preview Your Recording</p>
        <audio id="preview" controls style="width: 100%;"></audio>
        <div id="audioFallback" style="text-align: center; margin-top: 10px; display: none;">
          <p style="color: var(--warning); font-size: 0.9rem;">
            üîß Audio player not working? 
            <button onclick="downloadAudio()" style="background: var(--warning); color: #000; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 500;">
              Download Recording
            </button>
          </p>
        </div>
      </div>

      <div id="result" style="margin-top:20px"></div>

      <!-- Pending Requests Section -->
      <div id="pendingRequestsSection" class="hidden">
        <h3 style="margin-top:32px; font-family: var(--font-main);">Pending Requests</h3>
        <div id="pendingRequestsList" class="grid">
          <!-- Pending requests will appear here -->
        </div>
      </div>

      <h3 style="margin-top:32px; font-family: var(--font-main);">My Voice Messages</h3>
      <div id="grid" class="grid"></div>
    </div>

    <!-- receiver -->
    <div id="receiverView" hidden>
      <h3>Incoming Voice Message üîä</h3>
      
      <!-- Enhanced Audio Player -->
      <div id="audioPlayerSection">
        <audio id="playAudio" controls style="width: 100%;" preload="auto"></audio>
        <div id="receiverAudioFallback" style="text-align: center; margin-top: 10px; display: none;">
          <p style="color: var(--warning); margin-bottom: 10px;">
            üîß Can't play audio? Try downloading the voice message:
          </p>
          <button onclick="downloadReceiverAudio()" style="background: var(--warning); color: #000; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 500;">
            üì• Download Voice Message
          </button>
        </div>
      </div>
      
      <button id="playBtn" class="btn-primary">‚ñ∂Ô∏è Play Message</button>
      <div id="receiverStatus" style="margin-top:16px;"></div>
      <div id="revealSection" style="margin-top:16px"></div>
    </div>
  </div>

  <div id="loader" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;color:#fff;z-index:1400; font-family: var(--font-main);">
    <div style="text-align: center;">
      <div style="font-size: 3rem; margin-bottom: 20px;">üéµ</div>
      <div>Loading Echo...</div>
    </div>
  </div>

<script>
// -------------------------
// MOBILE AUDIO FIXES - ENHANCED
// -------------------------

// Detect mobile device
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// Check if iOS Safari
function isIOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}

// Enhanced audio format detection
function getSupportedAudioFormat() {
  const audio = document.createElement('audio');
  if (audio.canPlayType('audio/mp3')) return 'audio/mp3';
  if (audio.canPlayType('audio/wav')) return 'audio/wav';
  if (audio.canPlayType('audio/ogg')) return 'audio/ogg';
  if (audio.canPlayType('audio/webm')) return 'audio/webm';
  if (audio.canPlayType('audio/m4a')) return 'audio/mp4';
  return 'audio/mp3'; // fallback
}

// -------------------------
// BASIC INIT
// -------------------------
const BASE_URL = window.location.origin;
const params = new URLSearchParams(window.location.search);
const voiceId = params.get("v");
const loader = document.getElementById("loader");
const app = document.getElementById("app");
const senderView = document.getElementById("senderView");
const receiverView = document.getElementById("receiverView");
const themeBtn = document.getElementById("themeBtn");
const guideBtn = document.getElementById("guideBtn");

// Enhanced mobile detection and handling
if (isMobileDevice()) {
  document.getElementById('mobileWarning').style.display = 'block';
  
  // Add iOS specific tips
  if (isIOS()) {
    const warningDiv = document.getElementById('mobileWarning');
    warningDiv.innerHTML += `
      <div style="margin-top: 10px; padding: 10px; background: rgba(255,165,2,0.2); border-radius: 8px;">
        <strong>üçé iOS Users:</strong> Make sure to "Allow" microphone access and use Safari for best results.
      </div>
    `;
  }
}

// Initialize user ID
if (!localStorage.getItem('echo_id')) {
  localStorage.setItem('echo_id', 'echo_' + Math.random().toString(36).slice(2,9));
}
const SENDER_ID = localStorage.getItem('echo_id');

// Initialize storage
if (!localStorage.getItem('echo_voices')) {
  localStorage.setItem('echo_voices', JSON.stringify([]));
}
if (!localStorage.getItem('echo_requests')) {
  localStorage.setItem('echo_requests', JSON.stringify([]));
}

/* THEME */
let dark = true;
themeBtn.onclick = () => {
  dark = !dark;
  document.body.classList.toggle('light', !dark);
  themeBtn.textContent = dark ? "üåó Theme" : "‚òÄÔ∏è Theme";
};

/* GUIDE */
guideBtn.onclick = () => {
  alert("üéµ Echo Voice Messenger\n\n‚òÖ Record voice messages\n‚òÖ Set privacy levels\n‚òÖ Share via link or QR code\n‚òÖ Track message statistics\n‚òÖ Delete messages anytime\n‚òÖ Handle identity requests\n\nüì± Mobile Tips: Use headphones for better quality! Allow microphone permissions when prompted.");
};

/* -------------------------
   ON LOAD - show UI
   ------------------------- */
window.addEventListener('load', () => {
  setTimeout(() => {
    loader.style.display = 'none';
    app.hidden = false;
    if (voiceId) {
      senderView.hidden = true;
      receiverView.hidden = false;
      loadReceiver();
    } else {
      senderView.hidden = false;
      receiverView.hidden = true;
      loadDashboard();
      loadPendingRequests();
    }
  }, 1000);
});

/* -------------------------
   ENHANCED RECORDING - MOBILE FIXED
   ------------------------- */
let mediaRecorder, chunks = [];
let recordedBlob = null;
let audioStream = null;
const micBtn = document.getElementById('micBtn');
const stopBtn = document.getElementById('stopBtn');
const preview = document.getElementById('preview');
const uploadBtn = document.getElementById('uploadBtn');
const result = document.getElementById('result');
const audioPreviewSection = document.getElementById('audioPreviewSection');
const recordingStatus = document.getElementById('recordingStatus');

// Enhanced recording function with better mobile support
micBtn.onclick = async () => {
  try {
    // Clear previous status
    recordingStatus.innerHTML = '';
    
    // Mobile-specific permission handling
    if (isMobileDevice()) {
      showNotification("üì± Please allow microphone access when prompted");
    }
    
    // Stop any existing stream
    if (audioStream) {
      audioStream.getTracks().forEach(track => track.stop());
    }
    
    // Enhanced audio constraints for mobile
    const constraints = {
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        channelCount: 1,
        sampleRate: 44100,
        sampleSize: 16
      },
      video: false
    };
    
    // Get user media with enhanced error handling
    audioStream = await navigator.mediaDevices.getUserMedia(constraints);
    
    // Test if we actually have audio access
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioContext.createMediaStreamSource(audioStream);
    
    // Mobile-compatible MIME types
    const mimeTypes = [
      'audio/webm;codecs=opus',
      'audio/mp4;codecs=mp4a',
      'audio/webm',
      'audio/mp4',
      'audio/ogg;codecs=opus'
    ];
    
    let supportedType = '';
    for (let type of mimeTypes) {
      if (MediaRecorder.isTypeSupported(type)) {
        supportedType = type;
        break;
      }
    }
    
    if (!supportedType) {
      // Fallback to default
      supportedType = 'audio/webm';
    }
    
    const options = { 
      mimeType: supportedType,
      audioBitsPerSecond: 128000 
    };
    
    mediaRecorder = new MediaRecorder(audioStream, options);
    chunks = [];
    
    mediaRecorder.ondataavailable = (e) => {
      if (e.data && e.data.size > 0) {
        chunks.push(e.data);
      }
    };
    
    mediaRecorder.onstop = () => {
      recordedBlob = new Blob(chunks, { 
        type: mediaRecorder.mimeType || 'audio/webm' 
      });
      
      // Enhanced audio URL creation with error handling
      try {
        const audioUrl = URL.createObjectURL(recordedBlob);
        preview.src = audioUrl;
        
        // Show audio preview section
        audioPreviewSection.classList.remove('hidden');
        
        // Enhanced audio playback testing
        testAudioPlayback(preview, () => {
          console.log("Audio playback test successful");
          document.getElementById('audioFallback').style.display = 'none';
        }, () => {
          console.log("Audio playback test failed, showing fallback");
          document.getElementById('audioFallback').style.display = 'block';
        });
        
        uploadBtn.hidden = false;
        showNotification("‚úÖ Recording completed successfully");
        
      } catch (error) {
        console.error("Error creating audio URL:", error);
        recordingStatus.innerHTML = `
          <span style="color: var(--danger);">‚ùå Error processing recording</span>
        `;
      }
    };
    
    mediaRecorder.onerror = (event) => {
      console.error("MediaRecorder error:", event);
      recordingStatus.innerHTML = `
        <span style="color: var(--danger);">‚ùå Recording error occurred</span>
      `;
    };
    
    // Start recording with timeslice for better mobile performance
    mediaRecorder.start(1000); // Collect data every second
    
    AppState.isRecording = true;
    micBtn.classList.add('recording');
    stopBtn.disabled = false;
    
    recordingStatus.innerHTML = `
      <span style="color: var(--success);">‚óè Recording... Speak now!</span>
    `;
    
    showNotification("üé§ Recording started...");
    
  } catch (err) {
    console.error("Recording error:", err);
    let errorMessage = 'Please allow microphone access to record voice messages.';
    
    if (err.name === 'NotAllowedError') {
      errorMessage = '‚ùå Microphone access denied. Please allow microphone permissions in your browser settings and refresh the page.';
    } else if (err.name === 'NotFoundError') {
      errorMessage = '‚ùå No microphone found. Please check your device.';
    } else if (err.name === 'NotSupportedError') {
      errorMessage = '‚ùå Your browser does not support audio recording. Try using Chrome or Safari.';
    } else if (err.name === 'NotReadableError') {
      errorMessage = '‚ùå Microphone is already in use by another application.';
    }
    
    recordingStatus.innerHTML = `
      <span style="color: var(--danger);">${errorMessage}</span>
    `;
    
    // Show alert for critical errors
    if (err.name !== 'NotAllowedError') {
      setTimeout(() => alert(errorMessage), 500);
    }
  }
};

// Enhanced audio playback testing
function testAudioPlayback(audioElement, successCallback, errorCallback) {
  let playAttempt = setTimeout(() => {
    errorCallback();
  }, 2000);
  
  audioElement.oncanplaythrough = () => {
    clearTimeout(playAttempt);
    successCallback();
  };
  
  audioElement.onerror = () => {
    clearTimeout(playAttempt);
    errorCallback();
  };
  
  // Force load the audio
  audioElement.load();
}

stopBtn.onclick = () => {
  if (mediaRecorder && AppState.isRecording) {
    mediaRecorder.stop();
    AppState.isRecording = false;
    micBtn.classList.remove('recording');
    stopBtn.disabled = true;
    recordingStatus.innerHTML = '';
    
    // Stop all tracks
    if (audioStream) {
      audioStream.getTracks().forEach(track => track.stop());
      audioStream = null;
    }
    
    showNotification("‚èπ Recording stopped");
  }
};

// Enhanced download audio fallback
function downloadAudio() {
  if (recordedBlob) {
    try {
      const url = URL.createObjectURL(recordedBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `voice-message-${Date.now()}.${getFileExtension(recordedBlob.type)}`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    } catch (error) {
      console.error("Download error:", error);
      alert("‚ùå Download failed. Please try again.");
    }
  }
}

function getFileExtension(mimeType) {
  const extensions = {
    'audio/webm': 'webm',
    'audio/mp4': 'm4a',
    'audio/ogg': 'ogg',
    'audio/wav': 'wav',
    'audio/mpeg': 'mp3'
  };
  return extensions[mimeType] || 'audio';
}

// Enhanced download receiver audio
function downloadReceiverAudio() {
  const voiceData = getVoiceMessage(voiceId);
  if (voiceData && voiceData.audioBlob) {
    try {
      const audioBlob = base64ToBlob(voiceData.audioBlob);
      const url = URL.createObjectURL(audioBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `voice-message-${voiceId}.${getFileExtension(voiceData.mimeType)}`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    } catch (error) {
      console.error("Download error:", error);
      alert("‚ùå Download failed. The voice message may be corrupted.");
    }
  }
}

/* -------------------------
   ENHANCED UPLOAD + DASHBOARD
   ------------------------- */
uploadBtn.onclick = async () => {
  if (!recordedBlob) {
    showNotification("‚ùå Please record a voice message first");
    return;
  }

  const privacy = document.getElementById('privacy').value;
  const expiry = document.getElementById('expiry').value;
  const senderName = document.getElementById('senderName').value || 'Anonymous';

  uploadBtn.disabled = true;
  uploadBtn.innerHTML = '‚è≥ Uploading...';

  try {
    // Show uploading status
    result.innerHTML = `
      <div style="background: rgba(255, 165, 2, 0.1); border: 1px solid rgba(255, 165, 2, 0.3); border-radius: 12px; padding: 15px; text-align: center;">
        <span>‚è≥ Processing and uploading your voice message...</span>
      </div>
    `;

    // Simulate upload delay
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    const voiceData = {
      id: 'voice_' + Math.random().toString(36).slice(2,11),
      senderName: senderName,
      privacy: privacy,
      expiry: expiry,
      timestamp: new Date().toISOString(),
      senderId: SENDER_ID,
      openCount: 0,
      playCount: 0,
      audioBlob: await blobToBase64(recordedBlob),
      mimeType: recordedBlob.type || 'audio/webm'
    };

    // Save to localStorage
    saveVoiceMessage(voiceData);
    
    const shareLink = `${window.location.origin}${window.location.pathname}?v=${voiceData.id}`;
    
    result.innerHTML = `
      <div class="fade-in" style="background: rgba(46, 213, 115, 0.1); border: 1px solid rgba(46, 213, 115, 0.3); border-radius: 16px; padding: 20px;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
          <span style="font-size: 1.5rem;">‚úÖ</span>
          <span style="font-weight: 600;">Voice Message Uploaded!</span>
        </div>
        <p style="margin-bottom: 12px; font-weight: 500;">Share this link:</p>
        <input value="${shareLink}" style="width:100%; padding:12px; border-radius:10px; background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.2); color:inherit; margin-bottom:15px;" readonly>
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
          <button class="btn-primary" onclick="copyToClipboard('${shareLink}')">üìã Copy Link</button>
          <button class="btn-primary" onclick="generateQRCode('${shareLink}')">üì± QR Code</button>
          <button class="btn-primary" onclick="testMessage('${voiceData.id}')">üîä Test Playback</button>
        </div>
        <div style="margin-top: 15px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 10px;">
          <small>Privacy: ${getPrivacyText(privacy)} ‚Ä¢ Expiry: ${getExpiryText(expiry)}</small>
        </div>
      </div>
    `;

    await loadDashboard();
    loadPendingRequests();
    
    // Reset recording state
    recordedBlob = null;
    audioPreviewSection.classList.add('hidden');
    uploadBtn.hidden = true;
    
  } catch (e) {
    console.error("Upload error:", e);
    result.innerHTML = `
      <div style="background: rgba(255, 71, 87, 0.1); border: 1px solid rgba(255, 71, 87, 0.3); border-radius: 12px; padding: 15px; text-align: center;">
        <span style="color: var(--danger);">‚ùå Upload failed: ${e.message}. Please try again.</span>
      </div>
    `;
  } finally {
    uploadBtn.disabled = false;
    uploadBtn.innerHTML = '‚¨ÜÔ∏è Upload Voice';
  }
};

// Test message playback
function testMessage(messageId) {
  window.open(`?v=${messageId}`, '_blank');
}

// Convert blob to base64 for mobile storage
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// Convert base64 back to blob for playback
function base64ToBlob(base64) {
  try {
    const byteString = atob(base64.split(',')[1]);
    const mimeString = base64.split(',')[0].split(':')[1].split(';')[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    
    for (let i = 0; i < byteString.length; i++) {
      ia[i] = byteString.charCodeAt(i);
    }
    
    return new Blob([ab], { type: mimeString });
  } catch (error) {
    console.error("Base64 to blob conversion error:", error);
    throw new Error("Failed to process audio data");
  }
}

/* -------------------------
   ENHANCED RECEIVER FUNCTIONALITY
   ------------------------- */
async function loadReceiver() {
  try {
    const voiceData = getVoiceMessage(voiceId);
    
    if (!voiceData) {
      document.getElementById('receiverStatus').innerHTML = `
        <div style="background: rgba(255, 71, 87, 0.1); border: 1px solid rgba(255, 71, 87, 0.3); border-radius: 12px; padding: 15px; text-align: center;">
          <span style="color: var(--danger);">Voice message not found or expired</span>
          <p style="margin-top: 8px; font-size: 0.9rem; color: rgba(255,255,255,0.7);">
            The message may have been deleted or the link is incorrect.
          </p>
        </div>
      `;
      return;
    }
    
    // Update voice stats
    voiceData.openCount = (voiceData.openCount || 0) + 1;
    saveVoiceMessage(voiceData);
    
    // Enhanced audio setup
    const playAudio = document.getElementById('playAudio');
    const playBtn = document.getElementById('playBtn');
    
    if (voiceData.audioBlob) {
      try {
        // Convert base64 back to blob for playback
        const audioBlob = base64ToBlob(voiceData.audioBlob);
        const audioUrl = URL.createObjectURL(audioBlob);
        playAudio.src = audioUrl;
        
        // Enhanced audio event handling
        playAudio.oncanplaythrough = () => {
          console.log("Audio ready for playback");
          playBtn.disabled = false;
        };
        
        playAudio.onerror = (e) => {
          console.error("Audio playback error:", e);
          document.getElementById('receiverAudioFallback').style.display = 'block';
          playBtn.disabled = true;
        };
        
        // Preload audio for better mobile experience
        playAudio.load();
        
      } catch (error) {
        console.error("Audio processing error:", error);
        document.getElementById('receiverAudioFallback').style.display = 'block';
        playBtn.disabled = true;
      }
    } else {
      throw new Error("No audio data found in message");
    }

    // Enhanced play button functionality
    playBtn.onclick = () => {
      if (!playAudio.src) return;
      
      voiceData.playCount = (voiceData.playCount || 0) + 1;
      saveVoiceMessage(voiceData);
      
      // Enhanced play with error handling
      const playPromise = playAudio.play();
      
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            document.getElementById('receiverStatus').innerHTML = `
              <div style="background: rgba(46, 213, 115, 0.1); border: 1px solid rgba(46, 213, 115, 0.3); border-radius: 12px; padding: 12px; text-align: center;">
                <span style="color: var(--success);">‚úÖ Playing voice message...</span>
              </div>
            `;
          })
          .catch(err => {
            console.error("Play error:", err);
            document.getElementById('receiverAudioFallback').style.display = 'block';
            document.getElementById('receiverStatus').innerHTML = `
              <div style="background: rgba(255, 71, 87, 0.1); border: 1px solid rgba(255, 71, 87, 0.3); border-radius: 12px; padding: 12px; text-align: center;">
                <span style="color: var(--danger);">‚ùå Could not play audio automatically. Use the download button above.</span>
              </div>
            `;
          });
      }
    };
    
    // Handle audio ended event
    playAudio.onended = () => {
      document.getElementById('receiverStatus').innerHTML = `
        <div style="background: rgba(46, 213, 115, 0.1); border: 1px solid rgba(46, 213, 115, 0.3); border-radius: 12px; padding: 12px; text-align: center;">
          <span style="color: var(--success);">‚úÖ Voice message finished playing</span>
        </div>
      `;
    };
    
    // Handle identity reveal (existing functionality)
    handleIdentityReveal(voiceData);
    
  } catch (e) {
    console.error("Receiver load error:", e);
    document.getElementById('receiverStatus').innerHTML = `
      <div style="background: rgba(255, 71, 87, 0.1); border: 1px solid rgba(255, 71, 87, 0.3); border-radius: 12px; padding: 15px; text-align: center;">
        <span style="color: var(--danger);">Error loading voice message: ${e.message}</span>
        <p style="margin-top: 8px; font-size: 0.9rem; color: rgba(255,255,255,0.7);">
          Please try refreshing the page or contact the sender.
        </p>
      </div>
    `;
  }
}

// Handle identity reveal section
function handleIdentityReveal(voiceData) {
  const revealSection = document.getElementById('revealSection');
  
  if (voiceData.privacy === 'auto_reveal') {
    revealSection.innerHTML = `
      <div style="background: rgba(46, 213, 115, 0.1); border: 1px solid rgba(46, 213, 115, 0.3); border-radius: 12px; padding: 15px; text-align: center;">
        <span>üë§ Sender: <b>${voiceData.senderName}</b></span>
      </div>
    `;
  } else if (voiceData.privacy === 'reveal_on_request') {
    if (voiceData.revealApproved) {
      revealSection.innerHTML = `
        <div style="background: rgba(46, 213, 115, 0.1); border: 1px solid rgba(46, 213, 115, 0.3); border-radius: 12px; padding: 15px; text-align: center;">
          <span>üë§ Sender: <b>${voiceData.senderName}</b></span>
        </div>
      `;
    } else {
      revealSection.innerHTML = `
        <div style="background: rgba(255,255,255,0.08); border-radius: 12px; padding: 20px; text-align: center;">
          <h4 style="margin-bottom: 10px;">üîí Sender Identity Hidden</h4>
          <p style="color: rgba(255,255,255,0.7); margin-bottom: 15px; font-size: 0.9rem;">
            You can request to know who sent this message
          </p>
          <button class="btn-primary" id="reqBtn" style="padding: 12px 24px;">
            üîç Request Sender Identity
          </button>
        </div>
      `;
      
      document.getElementById('reqBtn').onclick = async () => {
        createIdentityRequest(voiceId);
        revealSection.innerHTML = `
          <div style="background: rgba(255, 165, 2, 0.1); border: 1px solid rgba(255, 165, 2, 0.3); border-radius: 12px; padding: 15px; text-align: center;">
            <span>‚è≥ Identity request sent to sender...</span>
            <p style="color: rgba(255,255,255,0.7); margin-top: 8px; font-size: 0.85rem;">
              You'll see the sender's name when they approve your request
            </p>
          </div>
        `;
      };
    }
  } else {
    revealSection.innerHTML = `
      <div style="background: rgba(255,255,255,0.08); border-radius: 12px; padding: 15px; text-align: center;">
        <span>üîí Sender prefers to remain anonymous</span>
      </div>
    `;
  }
}

// App State
const AppState = {
  currentUser: null,
  currentVoiceMessage: null,
  activeChats: [],
  isRecording: false,
  mediaRecorder: null,
  audioChunks: []
};

// [Include all the remaining functions from your original code]
// loadDashboard(), loadPendingRequests(), createIdentityRequest(), 
// approveRequest(), rejectRequest(), confirmDelete(), deleteVoiceMessage(), 
// generateQRCode(), saveVoiceMessage(), getVoiceMessages(), getVoiceMessage(), 
// getPendingRequests(), getPrivacyText(), getExpiryText(), copyToClipboard(), 
// showNotification() etc.

// Initialize the rest of the functionality
// [Copy all the remaining functions from your original code here]

// Enhanced notification system
function showNotification(message, duration = 3000) {
  // Remove existing notification
  const existingNotification = document.querySelector('.notification');
  if (existingNotification) {
    existingNotification.remove();
  }
  
  const notification = document.createElement('div');
  notification.className = 'notification';
  notification.textContent = message;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, duration);
}

// Enhanced copy to clipboard
function copyToClipboard(text) {
  navigator.clipboard.writeText(text).then(() => {
    showNotification('‚úÖ Link copied to clipboard!');
  }).catch(err => {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
      showNotification('‚úÖ Link copied to clipboard!');
    } catch (fallbackErr) {
      showNotification('‚ùå Failed to copy link');
    }
    document.body.removeChild(textArea);
  });
}

// Data management functions (simplified versions)
function saveVoiceMessage(voiceData) {
  const voices = JSON.parse(localStorage.getItem('echo_voices') || '[]');
  const existingIndex = voices.findIndex(v => v.id === voiceData.id);
  
  if (existingIndex >= 0) {
    voices[existingIndex] = voiceData;
  } else {
    voices.push(voiceData);
  }
  
  localStorage.setItem('echo_voices', JSON.stringify(voices));
}

function getVoiceMessage(id) {
  const voices = JSON.parse(localStorage.getItem('echo_voices') || '[]');
  return voices.find(v => v.id === id);
}

function getVoiceMessages() {
  return JSON.parse(localStorage.getItem('echo_voices') || '[]');
}

function getPrivacyText(privacy) {
  const privacyTexts = {
    'anonymous': 'Anonymous',
    'reveal_on_request': 'Reveal on Request',
    'auto_reveal': 'Auto Reveal'
  };
  return privacyTexts[privacy] || privacy;
}

function getExpiryText(expiry) {
  const expiryTexts = {
    'permanent': 'Permanent',
    '24h': '24 Hours',
    '1h': '1 Hour'
  };
  return expiryTexts[expiry] || expiry;
}

// Initialize dashboard (simplified)
function loadDashboard() {
  const voices = getVoiceMessages().filter(v => v.senderId === SENDER_ID);
  const grid = document.getElementById('grid');
  
  if (voices.length === 0) {
    grid.innerHTML = `
      <div style="text-align: center; padding: 40px; color: rgba(255,255,255,0.5);">
        <div style="font-size: 3rem; margin-bottom: 20px;">üéµ</div>
        <p>No voice messages yet. Record your first message above!</p>
      </div>
    `;
    return;
  }
  
  grid.innerHTML = voices.map(voice => `
    <div class="card fade-in">
      <div style="display: flex; justify-content: between; align-items: start; margin-bottom: 10px;">
        <strong style="flex: 1;">${voice.senderName}</strong>
        <span class="status-badge status-active">${getExpiryText(voice.expiry)}</span>
      </div>
      <small>Created: ${new Date(voice.timestamp).toLocaleDateString()}</small>
      <small>Plays: ${voice.playCount || 0} ‚Ä¢ Opens: ${voice.openCount || 0}</small>
      <div class="card-actions">
        <button class="card-action-btn btn-primary" onclick="window.open('?v=${voice.id}', '_blank')">
          üîó Open
        </button>
        <button class="card-action-btn" onclick="copyToClipboard('${window.location.origin}${window.location.pathname}?v=${voice.id}')">
          üìã Copy
        </button>
        <button class="card-action-btn btn-danger" onclick="confirmDelete('${voice.id}')">
          üóëÔ∏è Delete
        </button>
      </div>
    </div>
  `).join('');
}

// Placeholder for other functions
function loadPendingRequests() {
  // Your existing implementation
}

function createIdentityRequest(voiceId) {
  // Your existing implementation
}

function confirmDelete(voiceId) {
  if (confirm('Are you sure you want to delete this voice message? This action cannot be undone.')) {
    deleteVoiceMessage(voiceId);
  }
}

function deleteVoiceMessage(voiceId) {
  const voices = JSON.parse(localStorage.getItem('echo_voices') || '[]');
  const filteredVoices = voices.filter(v => v.id !== voiceId);
  localStorage.setItem('echo_voices', JSON.stringify(filteredVoices));
  loadDashboard();
  showNotification('üóëÔ∏è Voice message deleted');
}

function generateQRCode(url) {
  // Your existing QR code implementation
  alert(`QR Code for: ${url}\n\nQR code generation would appear here in the full implementation.`);
}
</script>
</body>
</html>
